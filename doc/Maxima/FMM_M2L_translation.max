from Fast-Multipole method (FMM) Solver Implementationhttps://aistudio.google.com/app/prompts?state=%7B%22ids%22:%5B%221iMLknKwbiMjTYf1iMgVCodYwCWJuVfaP%22%5D,%22action%22:%22open%22,%22userId%22:%22100958146796876347936%22,%22resourceKeys%22:%7B%7D%7D&usp=sharing

Okay, let's delve into the M2L derivation concept and provide Maxima code for both verification and derivation based on Taylor series matching.

1. Mathematical Idea Behind M2L Translation

The core idea is re-expressing a potential expansion.

Source: We have a charge distribution near a source point A. For points P far from A, its potential can be described by a Multipole Expansion (ME) centered at A:
Phi(P) = Sum_{j,k} M_{jk} * O_{jk}(P - A)
where M_{jk} are the multipole moments (coefficients) of the source and O_{jk} are the irregular solid harmonics (like 1/r, x/r^3, (x^2-y^2)/r^5, etc., centered at A). This expansion converges when |P - A| is large.

Target: We are interested in the potential near a target point B, which is far from the source point A. The potential in this region, generated by the distant source A, should be expressible as a Local Expansion (LE) centered at B:
Phi(P) = Sum_{l,m} L_{lm} * R_{lm}(P - B)
where L_{lm} are the local expansion coefficients and R_{lm} are the regular solid harmonics (like 1, x, x^2-y^2, etc., centered at B). This expansion converges when |P - B| is small.

M2L Goal: Find the relationship between the source moments M_{jk} and the target local coefficients L_{lm}. The relationship depends only on the translation vector D = B - A.

Derivation Method (Taylor Expansion Matching):

Take the Multipole Expansion Phi(P) = Sum M_{jk} * O_{jk}(P - A).

Choose the target center B as the point around which to analyze the potential's local behavior.

Taylor expand Phi(P) around the point P = B. The coefficients of this Taylor series (in terms of (px-bx), (py-by), (pz-bz)) describe the local potential behavior.

Take the generic Local Expansion Phi(P) = Sum L_{lm} * R_{lm}(P - B).

Recognize that the regular solid harmonics R_{lm}(P - B) are the basis functions for the Taylor expansion around B. For example, R_00 = 1, R_1x = px-bx, R_1y = py-by, R_2(x2-y2) = (px-bx)^2 - (py-by)^2, etc. (up to normalization constants depending on the exact R_lm definition).

Therefore, the coefficients L_{lm} of the local expansion must be directly related (often identical, up to constants) to the coefficients obtained from the Taylor expansion of the source's multipole potential around B.

By equating the Taylor coefficients from step 3 with the (scaled) L_{lm} coefficients from step 5, we can solve for L_{lm} in terms of the source M_{jk} and functions of the translation vector D = B - A (which appear when evaluating O_{jk} and its derivatives at B - A).

2. Maxima Code Structure

We will:

Define our specific real basis functions (H_i for regular, O_i for irregular).

Define symbolic potential functions PhiM and PhiL.

For Verification:

Calculate L_derived[i] using the explicit formulas provided in the previous answer.

Construct PhiM_translated (multipole centered at A) and PhiL_target (local centered at B using L_derived).

Taylor expand both around P=B up to order 2.

Show their difference (up to order 2) is zero.

For Derivation:

Construct PhiM_translated.

Construct PhiL_symbolic using unknown symbolic coefficients L[i].

Taylor expand both around P=B.

Extract coefficients of the Taylor basis terms (1, dp_x, dp_y, ..., dp_x*dp_y, ...) from both expansions (dp_x = px-bx, etc.).

Equate the corresponding coefficients and solve the resulting linear system for L[i].

3. Maxima Code (m2l_verification_derivation.mac)

/* Maxima Code for M2L Verification and Derivation (p=2) */

/* Kill previous state */
kill(all);
ratprint: false; /* Make output cleaner */
display2d: false; /* Use 1D output */

/* Options for Taylor */
taylor_simplifier: ratsimp; /* Simplify coefficients */
taylor_verbose: false;

/* --- 1. Define Basis Functions (Unnormalized Real Solid Harmonics) --- */

/* Helper for radial distance */
r(x, y, z) := sqrt(x^2 + y^2 + z^2);
Rinv(x, y, z) := 1 / r(x, y, z);

/* Regular Harmonics R_i (i=0..8) using basis H_i */
define(H[0](x, y, z), 1);
define(H[1](x, y, z), y);
define(H[2](x, y, z), z);
define(H[3](x, y, z), x);
define(H[4](x, y, z), x*y);
define(H[5](x, y, z), y*z);
define(H[6](x, y, z), 2*z^2 - x^2 - y^2);
define(H[7](x, y, z), x*z);
define(H[8](x, y, z), x^2 - y^2);

/* Irregular Harmonics O_i (i=0..8) using basis H_i */
/* O_i(v) = H_i(v) / |v|^(2*l+1), where l is the order (0, 1, or 2) */
O_factor[0]: Rinv(x, y, z);          /* l=0, 2l+1=1 */
O_factor[1]: Rinv(x, y, z)^3;        /* l=1, 2l+1=3 */
O_factor[2]: Rinv(x, y, z)^3;
O_factor[3]: Rinv(x, y, z)^3;
O_factor[4]: Rinv(x, y, z)^5;        /* l=2, 2l+1=5 */
O_factor[5]: Rinv(x, y, z)^5;
O_factor[6]: Rinv(x, y, z)^5;
O_factor[7]: Rinv(x, y, z)^5;
O_factor[8]: Rinv(x, y, z)^5;

for i:0 thru 8 do (
    define(O[i](x, y, z), H[i](x, y, z) * O_factor[i])
);

/* --- 2. Define Symbolic Potential Expansions --- */

/* Multipole Expansion PhiM centered at origin */
PhiM(x, y, z, M) := sum(M[i] * O[i](x, y, z), i, 0, 8);

/* Local Expansion PhiL centered at origin */
PhiL(x, y, z, L) := sum(L[i] * H[i](x, y, z), i, 0, 8);

/* --- 3. Setup for Verification and Derivation --- */

/* Define symbolic points P, A, B */
P: [px, py, pz];
A: [ax, ay, az];
B: [bx, by, bz];

/* Define relative vectors */
P_rel_A: P - A; /* Vector from A to P */
P_rel_B: P - B; /* Vector from B to P */
D: B - A;       /* Translation vector from A to B */
D_neg: -D;      /* Vector from B to A, used for O_lm(-D) = O_lm(A-B) */

/* Define symbolic multipole moments for source A */
array(M, 8);

/* --- 4. Verification --- */
print("--- Starting Verification ---");

/* 4.1 Calculate Translation Operators O_trans = O_i(D_neg) = O_i(A-B) */
O_trans: makelist(0, 9); /* Maxima lists are 1-based, but use 0..8 conceptually */
for i:0 thru 8 do (
    O_trans[i+1]: O[i](D_neg[1], D_neg[2], D_neg[3])
);
/* Assign to named vars for readability, matching kernel's O_trans[0..8] */
O00: O_trans[1]; O1y: O_trans[2]; O1z: O_trans[3]; O1x: O_trans[4];
O2xy: O_trans[5]; O2yz: O_trans[6]; O2z2: O_trans[7]; O2xz: O_trans[8]; O2x2y2: O_trans[9];

/* 4.2 Calculate L_derived using the explicit M2L formulas from previous answer */
L_derived: makelist(0, 9);
/* Assign M[i] to named vars for readability */
M00: M[0]; M1y: M[1]; M1z: M[2]; M1x: M[3];
M2xy: M[4]; M2yz: M[5]; M2z2: M[6]; M2xz: M[7]; M2x2y2: M[8];

L_derived[1]: M00*O00;                                                /* L[0] */
L_derived[2]: M00*O1y + M1y*O00;                                      /* L[1] */
L_derived[3]: M00*O1z + M1z*O00;                                      /* L[2] */
L_derived[4]: M00*O1x + M1x*O00;                                      /* L[3] */
L_derived[5]: M00*O2xy + M2xy*O00 + (M1x*O1y + M1y*O1x);               /* L[4] */
L_derived[6]: M00*O2yz + M2yz*O00 + (M1y*O1z + M1z*O1y);               /* L[5] */
L_derived[7]: M00*O2z2 + M2z2*O00 + 2*(M1z*O1z) - (M1x*O1x) - (M1y*O1y); /* L[6] */
L_derived[8]: M00*O2xz + M2xz*O00 + (M1x*O1z + M1z*O1x);               /* L[7] */
L_derived[9]: M00*O2x2y2 + M2x2y2*O00 + (M1x*O1x - M1y*O1y);           /* L[8] */

/* Convert list to array for PhiL function */
L_derived_arr: array(L_ derived_ symbolic, 8);
for i:0 thru 8 do L_derived_arr[i]: L_derived[i+1];

/* 4.3 Define the two potentials to compare */
/* Potential from source M at A, evaluated at P */
PhiM_translated: PhiM(P_rel_A[1], P_rel_A[2], P_rel_A[3], M);
/* Potential from target local expansion at B (using derived L), evaluated at P */
PhiL_target: PhiL(P_rel_B[1], P_rel_B[2], P_rel_B[3], L_derived_arr);

/* 4.4 Taylor expand both around P = B up to order 2 */
/* Variables for expansion: px, py, pz. Point: bx, by, bz */
taylor_order: 2;
print("Calculating Taylor Expansion of Translated Multipole (takes time)...");
taylor_M: taylor(PhiM_translated, P, B, taylor_order);
print("Calculating Taylor Expansion of Target Local Expansion...");
taylor_L: taylor(PhiL_target, P, B, taylor_order);

/* 4.5 Compare the expansions */
print("Comparing Taylor expansions (difference should be O(>2) or zero)...");
difference: taylor_M - taylor_L;
print("Simplifying difference...");
simplified_diff: ratsimp(difference);

print("Simplified Difference (Verification):");
print(simplified_diff); /* Should be 0 or contain terms of order > taylor_order */
if simplified_diff = 0 then print("Verification SUCCESSFUL!")
else print("Verification FAILED or difference contains higher order terms.");


/* --- 5. Derivation --- */
print("--- Starting Derivation (Coefficient Matching) ---");

/* 5.1 Define symbolic local coefficients for target B */
array(L, 8);

/* 5.2 Define potentials */
/* Source potential (same as before) */
/* PhiM_translated: PhiM(P_rel_A[1], P_rel_A[2], P_rel_A[3], M); */
/* Target potential with unknown L coefficients */
PhiL_symbolic: PhiL(P_rel_B[1], P_rel_B[2], P_rel_B[3], L);

/* 5.3 Taylor expand both around P = B */
print("Calculating Taylor Expansion of Translated Multipole (reuse)...");
/* taylor_M: taylor(PhiM_translated, P, B, taylor_order); */
print("Calculating Taylor Expansion of Symbolic Local Expansion...");
taylor_L_sym: taylor(PhiL_symbolic, P, B, taylor_order);

/* 5.4 Extract coefficients and equate */
/* Define delta variables for Taylor expansion */
dp_x: px - bx;
dp_y: py - by;
dp_z: pz - bz;

/* List to store equations L[i] = expression_in_M_and_D */
equations: [];

/* Function to extract coefficient for a given term pattern */
/* Pattern is like dp_x^i * dp_y^j * dp_z^k */
get_coeffs(expr, pattern_vars, term_pattern) := block(
    [temp: expr, coeff_val],
    for var in pattern_vars do (
        temp: ratcoef(temp, var, hipow(term_pattern, var))
    ),
    coeff_val: temp,
    return(coeff_val)
)$

/* Match coefficient of 1 (order 0) */
coeff_M_0: ratcoef(taylor_M, dp_x, 0); coeff_M_0: ratcoef(coeff_M_0, dp_y, 0); coeff_M_0: ratcoef(coeff_M_0, dp_z, 0);
coeff_L_0: ratcoef(taylor_L_sym, dp_x, 0); coeff_L_0: ratcoef(coeff_L_0, dp_y, 0); coeff_L_0: ratcoef(coeff_L_0, dp_z, 0);
/* H[0] is 1, so coeff_L_0 should be L[0] */
print("Matching coeff of 1: ", coeff_L_0, " = ", coeff_M_0);
/* Assume coeff_L_0 = L[0] based on H[0]=1 */
eq0: L[0] = coeff_M_0;
equations: endcons(eq0, equations);

/* Match coefficients of dp_x, dp_y, dp_z (order 1) */
coeff_M_x: ratcoef(ratcoef(ratcoef(taylor_M, dp_y, 0), dp_z, 0), dp_x, 1);
coeff_L_x: ratcoef(ratcoef(ratcoef(taylor_L_sym, dp_y, 0), dp_z, 0), dp_x, 1);
/* H[3] is x, so coeff_L_x should be L[3] */
print("Matching coeff of dp_x: ", coeff_L_x, " = ", coeff_M_x);
eq3: L[3] = coeff_M_x;
equations: endcons(eq3, equations);

coeff_M_y: ratcoef(ratcoef(ratcoef(taylor_M, dp_x, 0), dp_z, 0), dp_y, 1);
coeff_L_y: ratcoef(ratcoef(ratcoef(taylor_L_sym, dp_x, 0), dp_z, 0), dp_y, 1);
/* H[1] is y, so coeff_L_y should be L[1] */
print("Matching coeff of dp_y: ", coeff_L_y, " = ", coeff_M_y);
eq1: L[1] = coeff_M_y;
equations: endcons(eq1, equations);

coeff_M_z: ratcoef(ratcoef(ratcoef(taylor_M, dp_x, 0), dp_y, 0), dp_z, 1);
coeff_L_z: ratcoef(ratcoef(ratcoef(taylor_L_sym, dp_x, 0), dp_y, 0), dp_z, 1);
/* H[2] is z, so coeff_L_z should be L[2] */
print("Matching coeff of dp_z: ", coeff_L_z, " = ", coeff_M_z);
eq2: L[2] = coeff_M_z;
equations: endcons(eq2, equations);


/* Match coefficients of order 2 terms (dp_x*dp_y, dp_y*dp_z, etc.) */
/* Need to relate Taylor coeffs to L[4]..L[8] based on H[4]..H[8] */
/* Example: Coefficient of dp_x*dp_y */
coeff_M_xy: ratcoef(ratcoef(ratcoef(taylor_M, dp_z, 0), dp_x, 1), dp_y, 1);
coeff_L_xy: ratcoef(ratcoef(ratcoef(taylor_L_sym, dp_z, 0), dp_x, 1), dp_y, 1);
/* H[4] is xy, so coeff_L_xy should be L[4] */
print("Matching coeff of dp_x*dp_y: ", coeff_L_xy, " = ", coeff_M_xy);
eq4: L[4] = coeff_M_xy;
equations: endcons(eq4, equations);

/* Example: Coefficient of dp_y*dp_z */
coeff_M_yz: ratcoef(ratcoef(ratcoef(taylor_M, dp_x, 0), dp_y, 1), dp_z, 1);
coeff_L_yz: ratcoef(ratcoef(ratcoef(taylor_L_sym, dp_x, 0), dp_y, 1), dp_z, 1);
/* H[5] is yz, so coeff_L_yz should be L[5] */
print("Matching coeff of dp_y*dp_z: ", coeff_L_yz, " = ", coeff_M_yz);
eq5: L[5] = coeff_M_yz;
equations: endcons(eq5, equations);

/* Example: Coefficient of dp_x*dp_z */
coeff_M_xz: ratcoef(ratcoef(ratcoef(taylor_M, dp_y, 0), dp_x, 1), dp_z, 1);
coeff_L_xz: ratcoef(ratcoef(ratcoef(taylor_L_sym, dp_y, 0), dp_x, 1), dp_z, 1);
/* H[7] is xz, so coeff_L_xz should be L[7] */
print("Matching coeff of dp_x*dp_z: ", coeff_L_xz, " = ", coeff_M_xz);
eq7: L[7] = coeff_M_xz;
equations: endcons(eq7, equations);

/* Need coefficients of dp_x^2, dp_y^2, dp_z^2 to solve for L[6] and L[8] */
coeff_M_x2: ratcoef(ratcoef(ratcoef(taylor_M, dp_y, 0), dp_z, 0), dp_x, 2);
coeff_L_x2: ratcoef(ratcoef(ratcoef(taylor_L_sym, dp_y, 0), dp_z, 0), dp_x, 2);
coeff_M_y2: ratcoef(ratcoef(ratcoef(taylor_M, dp_x, 0), dp_z, 0), dp_y, 2);
coeff_L_y2: ratcoef(ratcoef(ratcoef(taylor_L_sym, dp_x, 0), dp_z, 0), dp_y, 2);
coeff_M_z2: ratcoef(ratcoef(ratcoef(taylor_M, dp_x, 0), dp_y, 0), dp_z, 2);
coeff_L_z2: ratcoef(ratcoef(ratcoef(taylor_L_sym, dp_x, 0), dp_y, 0), dp_z, 2);

/* From PhiL_symbolic, the coeff of dp_x^2 comes from L[6]*(-dp_x^2) + L[8]*dp_x^2 */
/* => coeff_L_x2 = -L[6] + L[8] */
/* Similarly, coeff_L_y2 = -L[6] - L[8] */
/* And coeff_L_z2 = 2*L[6] */
print("Matching coeff of dp_x^2: ", coeff_L_x2, " = ", coeff_M_x2);
print("Matching coeff of dp_y^2: ", coeff_L_y2, " = ", coeff_M_y2);
print("Matching coeff of dp_z^2: ", coeff_L_z2, " = ", coeff_M_z2);

eq_x2: -L[6] + L[8] = coeff_M_x2;
eq_y2: -L[6] - L[8] = coeff_M_y2;
eq_z2: 2*L[6] = coeff_M_z2; /* This directly gives L[6] */

/* Solve for L[6] and L[8] */
/* Using eq_z2 */
eq6: L[6] = coeff_M_z2 / 2;
equations: endcons(eq6, equations);
/* Using eq_x2 and the solved L[6] */
eq8: L[8] = coeff_M_x2 + L[6];
equations: endcons(eq8, equations);
/* We could also use eq_y2 as a check: solve(eq_y2, L[8]) => L[8] = -coeff_M_y2 - L[6] */
/* Check: ratsimp((coeff_M_x2 + L[6]) - (-coeff_M_y2 - L[6])) should be 0 if consistent */
/* check_consistency: ratsimp((coeff_M_x2 + coeff_M_z2/2) - (-coeff_M_y2 - coeff_M_z2/2)); */
/* print("Consistency check (x2 vs y2,z2): ", check_consistency); */ /* Should be 0 */


/* 5.5 Display Derived Formulas */
print("--- Derived M2L Formulas (L[i] in terms of M[j] and vector A-B) ---");
derived_formulas: makelist(0, 9);
for i:0 thru 8 do (
    /* Substitute known L expressions into the equation for L[i] */
    /* This requires solving the 'equations' list, but here we constructed them directly */
    /* Apply ratsimp to simplify the expressions */
    derived_formulas[i+1]: ratsimp(rhs(equations[i+1])),
    printf(true, "L[~d] = ~m;~%", i, derived_formulas[i+1])
);

/* Compare derived formulas with the ones used in verification */
print("--- Comparing Derived Formulas with Verification Formulas ---");
comparison_failed: false;
for i:0 thru 8 do (
    diff_formula: ratsimp(derived_formulas[i+1] - L_derived[i+1]),
    if diff_formula # 0 then (
        printf(true, "Mismatch for L[~d]! Difference: ~m~%", i, diff_formula),
        comparison_failed: true
    )
);

if not comparison_failed then print("Derived formulas MATCH verification formulas!")
else print("Derived formulas DO NOT MATCH verification formulas!");

print("--- End ---");


Explanation:

Basis Functions (H[i], O[i]): Defines the 9 real regular (H) and irregular (O) solid harmonic basis functions based on the Cartesian combinations used previously.

Potentials (PhiM, PhiL): Defines functions to compute the potential given coefficients (M or L) and coordinates, summing over the basis functions.

Setup: Defines symbolic points and vectors. D_neg = A - B is the vector from the target center B to the source center A, which is the argument for the translation operators O_i.

Verification:

Calculates the 9 translation operator values O_trans[i+1] = O[i](A-B).

Calculates the expected L_derived[i+1] using the explicit formulas from the OpenCL kernel draft.

Constructs the potential PhiM_translated from the source M centered at A.

Constructs the potential PhiL_target from the derived local coefficients L_derived centered at B.

Uses Maxima's taylor function to expand both potentials around the target center B up to order 2.

Calculates the difference between the Taylor series and simplifies it using ratsimp. If the M2L formulas are correct up to order p=2, this difference should be zero (or only contain terms of order higher than 2, which taylor discards).

Derivation:

Uses taylor again on PhiM_translated and a symbolic PhiL_symbolic (with unknown L[i] coefficients).

Uses ratcoef to extract the coefficients of the Taylor basis terms (1, dp_x, dp_y, dp_z, dp_x*dp_y, ..., dp_z^2) from both expansions.

Relates the coefficients from PhiL_symbolic to the unknown L[i] based on the definition of the H[i] basis functions.

Equates the coefficients from PhiM_translated to the corresponding L[i] combinations.

This yields a system of 9 linear equations. The code directly constructs the solved equations for L[0] through L[8].

Prints the derived formulas for L[i] (which will be in terms of M[j] and components of A-B).

Finally, it compares these newly derived formulas against the L_derived formulas used in the verification step to ensure self-consistency.

How to Use:

Save the code as m2l_verification_derivation.mac.

Run Maxima.

Load the file: batch("m2l_verification_derivation.mac");

Observe the output. Pay attention to the "Simplified Difference (Verification)" (should be 0) and the comparison result at the end (should report MATCH). The derived formulas will also be printed.

This provides a rigorous analytical check (within the capabilities of the CAS) for the specific M2L formulas and demonstrates the coefficient-matching method for deriving them.