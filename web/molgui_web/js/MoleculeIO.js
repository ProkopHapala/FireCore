import { Vec3 } from "../../common_js/Vec3.js";
import { Mat3 } from "../../common_js/Mat3.js";
import { EditableMolecule } from "./EditableMolecule.js";

/// Export molecule as parsed arrays {pos, types, bonds, lvec}
export function exportAsParsed(mol) {
    const n = mol.atoms.length;
    const pos = new Float32Array(n * 3);
    const types = new Uint8Array(n);
    const bonds = [];
    for (let i = 0; i < n; i++) {
        const a = mol.atoms[i];
        const i3 = i * 3;
        pos[i3] = a.pos.x; pos[i3 + 1] = a.pos.y; pos[i3 + 2] = a.pos.z;
        types[i] = a.Z;
    }
    for (let i = 0; i < mol.bonds.length; i++) {
        const b = mol.bonds[i];
        b.ensureIndices(mol);
        bonds.push([b.a, b.b]);
    }
    return { pos, types, bonds, lvec: mol.lvec ? [mol.lvec[0].clone(), mol.lvec[1].clone(), mol.lvec[2].clone()] : null };
}

/// Append parsed system into molecule with optional translation/rotation; returns new atom ids.
export function appendParsedSystem(mol, other, opts = {}) {
    if (!other || !other.pos || !other.types) throw new Error('appendParsedSystem: other must have pos/types');
    const n = other.types.length | 0;
    const pos = (opts.pos !== undefined) ? opts.pos : new Vec3(0, 0, 0);
    const rot = (opts.rot !== undefined) ? opts.rot : null;
    const bPosVec = (pos instanceof Vec3);
    if (!bPosVec && !(Array.isArray(pos) && pos.length >= 3)) throw new Error('appendParsedSystem: opts.pos must be Vec3 or [x,y,z]');
    const px = bPosVec ? pos.x : pos[0];
    const py = bPosVec ? pos.y : pos[1];
    const pz = bPosVec ? pos.z : pos[2];

    const bRotMat3 = (rot instanceof Mat3);
    const bRotFlat = (!!rot && !bRotMat3 && (rot.length === 9));
    if (rot && !bRotMat3 && !bRotFlat) throw new Error('appendParsedSystem: opts.rot must be Mat3 or flat[9]');
    const tmp = new Vec3();
    const tmp2 = new Vec3();
    const ids = new Array(n);
    for (let i = 0; i < n; i++) {
        const i3 = i * 3;
        let x = other.pos[i3];
        let y = other.pos[i3 + 1];
        let z = other.pos[i3 + 2];
        if (bRotMat3) {
            tmp.set(x, y, z);
            rot.mulVec(tmp, tmp2);
            x = tmp2.x; y = tmp2.y; z = tmp2.z;
        } else if (bRotFlat) {
            const rx = rot[0] * x + rot[1] * y + rot[2] * z;
            const ry = rot[3] * x + rot[4] * y + rot[5] * z;
            const rz = rot[6] * x + rot[7] * y + rot[8] * z;
            x = rx; y = ry; z = rz;
        }
        ids[i] = mol.addAtom(x + px, y + py, z + pz, other.types[i]);
    }
    if (other.bonds && other.bonds.length) {
        for (const [a0, b0] of other.bonds) {
            const aId = ids[a0 | 0];
            const bId = ids[b0 | 0];
            if (aId === undefined || bId === undefined) throw new Error(`appendParsedSystem: bond refers to out-of-range atom a0=${a0} b0=${b0}`);
            mol.addBond(aId, bId);
        }
    }
    return ids;
}

/// Serialize molecule to XYZ format (optionally charges and lattice vectors).
export function toXYZString(mol, opts = {}) {
    const qs = opts.qs || null;
    const bQ = !!qs;
    const lvec = (opts.lvec !== undefined) ? opts.lvec : (mol.lvec || null);
    const out = [];
    out.push(String(mol.atoms.length));
    if (lvec && lvec.length === 3) {
        const a = lvec[0], b = lvec[1], c = lvec[2];
        out.push(`lvs ${a.x} ${a.y} ${a.z}   ${b.x} ${b.y} ${b.z}   ${c.x} ${c.y} ${c.z}`);
    } else {
        out.push('Generated by EditableMolecule');
    }
    for (let i = 0; i < mol.atoms.length; i++) {
        const at = mol.atoms[i];
        const sym = Z_TO_SYMBOL[at.Z] || 'X';
        const x = at.pos.x.toFixed(6);
        const y = at.pos.y.toFixed(6);
        const z = at.pos.z.toFixed(6);
        if (bQ) out.push(`${sym} ${x} ${y} ${z} ${(qs[i] !== undefined) ? qs[i] : 0.0}`);
        else out.push(`${sym} ${x} ${y} ${z}`);
    }
    return out.join('\n') + '\n';
}

/// Serialize molecule to MOL2 format including bonds and optional lattice vectors.
export function toMol2String(mol, opts = {}) {
    const lvec = (opts.lvec !== undefined) ? opts.lvec : (mol.lvec || null);
    const name = (opts.name !== undefined) ? String(opts.name) : 'EditableMolecule';
    const out = [];
    out.push('@<TRIPOS>MOLECULE');
    out.push(name);
    out.push(` ${mol.atoms.length} ${mol.bonds.length} 0 0 0`);
    out.push('SMALL');
    out.push('GASTEIGER');
    if (lvec && lvec.length === 3) {
        const a = lvec[0], b = lvec[1], c = lvec[2];
        out.push(`@lvs ${a.x} ${a.y} ${a.z}    ${b.x} ${b.y} ${b.z}   ${c.x} ${c.y} ${c.z}`);
    }
    out.push('');
    out.push('@<TRIPOS>ATOM');
    for (let i = 0; i < mol.atoms.length; i++) {
        const at = mol.atoms[i];
        const sym = Z_TO_SYMBOL[at.Z] || 'X';
        const aname = `${sym}${i + 1}`;
        const x = at.pos.x.toFixed(4);
        const y = at.pos.y.toFixed(4);
        const z = at.pos.z.toFixed(4);
        const q = (at.charge !== undefined && at.charge !== null) ? (+at.charge).toFixed(4) : '0.0000';
        out.push(`${String(i + 1).padStart(7)} ${aname.padEnd(6)} ${x.padStart(10)} ${y.padStart(10)} ${z.padStart(10)} ${sym.padEnd(5)} 1  UNL1  ${q.padStart(10)}`);
    }
    out.push('@<TRIPOS>BOND');
    for (let i = 0; i < mol.bonds.length; i++) {
        const b = mol.bonds[i];
        b.ensureIndices(mol);
        const a = b.a + 1;
        const c = b.b + 1;
        const ord = (b.order !== undefined && b.order !== null) ? String(b.order) : '1';
        out.push(`${String(i + 1).padStart(6)} ${String(a).padStart(5)} ${String(c).padStart(5)} ${ord}`);
    }
    out.push('');
    return out.join('\n') + '\n';
}

/// Parse MOL2 text into parsed arrays.
export function parseMol2(text) {
    const lines = text.split(/\r?\n/);
    let mode = '';
    let lvec = null;
    const apos = [];
    const types = [];
    const bonds = [];
    for (let il = 0; il < lines.length; il++) {
        const line = lines[il].trim();
        if (!line) continue;
        if (line.startsWith('@lvs')) {
            const p = line.split(/\s+/).slice(1).map(parseFloat);
            if (p.length >= 9) {
                lvec = [
                    new Vec3(p[0], p[1], p[2]),
                    new Vec3(p[3], p[4], p[5]),
                    new Vec3(p[6], p[7], p[8])
                ];
            }
            continue;
        }
        if (line.startsWith('@<TRIPOS>ATOM')) { mode = 'ATOM'; continue; }
        if (line.startsWith('@<TRIPOS>BOND')) { mode = 'BOND'; continue; }
        if (line.startsWith('@<TRIPOS>')) { mode = ''; continue; }
        if (mode === 'ATOM') {
            const parts = line.split(/\s+/);
            if (parts.length < 6) continue;
            const sym = normalizeSymbol(parts[1].replace(/[^A-Za-z].*$/, ''));
            const x = parseFloat(parts[2]);
            const y = parseFloat(parts[3]);
            const z = parseFloat(parts[4]);
            const Z = symbolToZ(sym);
            apos.push(x, y, z);
            types.push(Z);
        } else if (mode === 'BOND') {
            const parts = line.split(/\s+/);
            if (parts.length < 4) continue;
            const a = (parseInt(parts[1]) | 0) - 1;
            const b = (parseInt(parts[2]) | 0) - 1;
            if (a >= 0 && b >= 0) bonds.push([a, b]);
        }
    }
    return { pos: new Float32Array(apos), types: new Uint8Array(types), bonds, lvec };
}

/// Parse XYZ text into parsed arrays.
export function parseXYZ(text) {
    const lines = text.split(/\r?\n/);
    let i0 = 0;
    if (lines.length >= 2) i0 = 2;
    const pos = [];
    const types = [];
    for (let i = i0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;
        const parts = line.split(/\s+/);
        if (parts.length < 4) continue;
        const sym = parts[0];
        const x = parseFloat(parts[1]);
        const y = parseFloat(parts[2]);
        const z = parseFloat(parts[3]);
        if (!isFinite(x) || !isFinite(y) || !isFinite(z)) continue;
        const Z = asZ(sym);
        pos.push(x, y, z);
        types.push(Z);
    }
    return { pos: new Float32Array(pos), types: new Uint8Array(types), bonds: [], lvec: null };
}

/// Normalize element symbols (e.g., "cl" -> "Cl").
export function normalizeSymbol(s) {
    if (!s) return s;
    const a = s.trim();
    if (a.length === 1) return a.toUpperCase();
    return a[0].toUpperCase() + a.slice(1).toLowerCase();
}

/// Symbol to atomic number using internal table.
export function symbolToZ(sym) {
    const s = normalizeSymbol(sym);
    const z = SYMBOL_TO_Z[s];
    if (!z) throw new Error(`symbolToZ: unknown symbol '${sym}'`);
    return z;
}

/// Accept number or symbol and return atomic number.
export function asZ(x) {
    if (typeof x === 'number') return x | 0;
    if (typeof x !== 'string') throw new Error(`asZ: unsupported type ${typeof x}`);
    return symbolToZ(x);
}

/// These are intentionally small; expand only when needed.
export const SYMBOL_TO_Z = {
    H: 1, He: 2, C: 6, N: 7, O: 8, F: 9, Na: 11, Mg: 12, Al: 13, Si: 14, P: 15, S: 16, Cl: 17, K: 19, Ca: 20,
    Fe: 26, Cu: 29, Zn: 30, Se: 34, Br: 35, I: 53, Xe: 54
};

export const Z_TO_SYMBOL = {
    1: 'H', 2: 'He', 6: 'C', 7: 'N', 8: 'O', 9: 'F', 11: 'Na', 12: 'Mg', 13: 'Al', 14: 'Si', 15: 'P', 16: 'S', 17: 'Cl',
    19: 'K', 20: 'Ca', 26: 'Fe', 29: 'Cu', 30: 'Zn', 34: 'Se', 35: 'Br', 53: 'I', 54: 'Xe'
};

/// Install IO helpers onto EditableMolecule (instance methods call exported pure functions).
export function installMoleculeIOMethods(cls = EditableMolecule) {
    console.log('[installMoleculeIOMethods] installing on', cls && cls.name);
    if (!cls || !cls.prototype) throw new Error('installMoleculeIOMethods: invalid class');
    cls.prototype.exportAsParsed = function () { return exportAsParsed(this); };
    cls.prototype.appendParsedSystem = function (other, opts) { return appendParsedSystem(this, other, opts); };
    cls.prototype.toXYZString = function (opts) { return toXYZString(this, opts); };
    cls.prototype.toMol2String = function (opts) { return toMol2String(this, opts); };
    // Provide static access to symbol helpers for convenience.
    cls.normalizeSymbol = normalizeSymbol;
    cls.symbolToZ = symbolToZ;
    cls.asZ = asZ;
    cls.SYMBOL_TO_Z = SYMBOL_TO_Z;
    cls.Z_TO_SYMBOL = Z_TO_SYMBOL;
    cls.parseMol2 = parseMol2;
    cls.parseXYZ = parseXYZ;
}
