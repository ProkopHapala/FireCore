<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGPU N-Body DEBUG</title>
    <style>
        body { margin: 0; background: #222; color: #eee; font-family: monospace; display: flex; flex-direction: column; height: 100vh; }
        #controls { padding: 10px; background: #333; display: flex; gap: 10px; align-items: center; border-bottom: 1px solid #555; flex-wrap: wrap; }
        button { padding: 8px 16px; font-size: 14px; cursor: pointer; background: #444; color: white; border: 1px solid #666; }
        button:hover { background: #555; }
        label { display: flex; align-items: center; gap: 4px; font-size: 13px; }
        input[type=number] { width: 80px; padding: 6px; background: #222; color: #eee; border: 1px solid #555; }
        #container { position: relative; flex-grow: 1; display: flex; }
        canvas { width: 600px; height: 600px; background: #000; display: block; border: 1px solid #555; }
        #logs { flex-grow: 1; background: #111; overflow-y: auto; padding: 10px; font-size: 12px; white-space: pre; border-left: 1px solid #555; min-width: 400px; }
        .row { border-bottom: 1px solid #333; padding: 2px 0; }
        .hl { color: #f0f; font-weight: bold; }
    </style>
</head>
<body>

<div id="controls">
    <button id="btnStep">Step (Single Frame)</button>
    <button id="btnRun">Toggle Auto Run</button>
    <label>dt <input id="inpDt" type="number" step="0.001" min="0.001" max="1" /></label>
    <label>damp <input id="inpDamp" type="number" step="0.001" min="0.8" max="1.0" /></label>
    <label>r2max <input id="inpR2" type="number" step="0.1" min="0.1" max="64" /></label>
    <label>substeps <input id="inpSub" type="number" step="1" min="1" max="32" /></label>
    <label>mode
        <select id="selAlg" style="background:#222;color:#eee;border:1px solid #555;padding:6px;">
            <option value="brute" selected>Brute</option>
            <option value="grid">Grid</option>
        </select>
    </label>
    <input id="forceDiffBox" type="text" readonly style="width:520px; padding:6px; background:#111; color:#eee; border:1px solid #555;" value="" />
    <button id="btnCopyDiff">CopyDiff</button>
    <span id="status">Status: Ready</span>
</div>

<div id="container">
    <canvas id="canvas" width="600" height="600"></canvas>
    <div id="logs">LOG OUTPUT WAITING...</div>
</div>

<script type="module">

// =========================================================
// DEBUG CONFIGURATION
// =========================================================
const NUM_PARTICLES = 64;  // Particle count
const GRID_DIM = 4;        // 4x4 Grid
const WORLD_SIZE = 16.0;   // World is 0.0 to 16.0 units
const CELL_SIZE = WORLD_SIZE / GRID_DIM; // Each cell is 4.0 units
const GRID_TOTAL_CELLS = GRID_DIM * GRID_DIM;
const STRIDE = 6; // pos(2) vel(2) charge pad

// Physics Params
const SIM_PARAMS = new Float32Array([
    0.02,       // dt (matches C++ dt_frame/per_frame)
    0.996,      // damping factor per step (1 - 0.2*0.02)
    4.0,        // r2max (matches C++)
    GRID_DIM,   // grid dim
    CELL_SIZE   // cell size
]);

// =========================================================
// WGSL SHADERS (Simplified for Debug)
// =========================================================

const commonWGSL = `
    struct Params {
        dt: f32,
        damping: f32,
        r2max: f32,
        gridDim: f32,
        cellSize: f32,
    };

    struct Particle {
        pos: vec2<f32>,
        vel: vec2<f32>,
        charge: f32,
        pad: f32, 
    };

    struct SortKeyPair {
        key: u32,
        value: u32,
    };
`;

const computeForcesGridWGSL = `
    ${commonWGSL}
    @group(0) @binding(0) var<uniform> params : Params;
    @group(0) @binding(1) var<storage, read> particlesIn : array<Particle>;
    @group(0) @binding(2) var<storage, read_write> forces : array<vec2<f32>>;
    @group(0) @binding(3) var<storage, read> sortBuffer : array<SortKeyPair>;
    @group(0) @binding(4) var<storage, read> cellOffsets : array<u32>;
    @group(0) @binding(5) var<storage, read_write> cellCounts : array<atomic<u32>>;

    fn pairwiseForce(pa: vec2<f32>, pb: vec2<f32>, qq: f32, r2max: f32) -> vec2<f32> {
        let d = pa - pb;
        let r2 = dot(d, d);
        if (r2 < r2max && r2 > 0.0001) {
            let mr2 = r2max - r2;
            let fr = (1.0/(r2 + 0.01) + qq - 0.1) * mr2 * mr2;
            return d * fr;
        }
        return vec2<f32>(0.0);
    }

    @compute @workgroup_size(64)
    fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
        let index = GlobalInvocationID.x;
        if (index >= ${NUM_PARTICLES}) { return; }

        let p = particlesIn[index];
        var force = vec2<f32>(0.0);

        let gridPos = floor(p.pos / params.cellSize);
        let gx = i32(clamp(gridPos.x, 0.0, params.gridDim - 1.0));
        let gy = i32(clamp(gridPos.y, 0.0, params.gridDim - 1.0));

        for (var y = -1; y <= 1; y++) {
            for (var x = -1; x <= 1; x++) {
                let nx = gx + x;
                let ny = gy + y;
                if (nx < 0 || ny < 0 || nx >= i32(params.gridDim) || ny >= i32(params.gridDim)) { continue; }
                let cellKey = u32(ny * i32(params.gridDim) + nx);

                let start = cellOffsets[cellKey];
                let count = atomicLoad(&cellCounts[cellKey]);

                if (start != 0xFFFFFFFFu) {
                    for (var i = 0u; i < count; i++) {
                        let otherIdx = sortBuffer[start + i].value;
                        if (otherIdx == index) { continue; }
                        let otherP = particlesIn[otherIdx];
                        let qq = p.charge * otherP.charge;
                        force += pairwiseForce(p.pos, otherP.pos, qq, params.r2max);
                    }
                }
            }
        }
        forces[index] = force;
    }
`;

// 1. Binning
const computeBinningWGSL = `
    ${commonWGSL}
    @group(0) @binding(0) var<uniform> params : Params;
    @group(0) @binding(1) var<storage, read> particles : array<Particle>;
    @group(0) @binding(2) var<storage, read_write> sortBuffer : array<SortKeyPair>;
    @group(0) @binding(3) var<storage, read_write> cellOffsets : array<u32>;

    fn getGridHash(pos: vec2<f32>) -> u32 {
        let gridPos = floor(pos / params.cellSize);
        let x = i32(clamp(gridPos.x, 0.0, params.gridDim - 1.0));
        let y = i32(clamp(gridPos.y, 0.0, params.gridDim - 1.0));
        return u32(y * i32(params.gridDim) + x);
    }

    @compute @workgroup_size(64)
    fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
        let index = GlobalInvocationID.x;
        
        // Reset offsets first (hacky for small scale, usually done in separate pass)
        if (index < ${GRID_TOTAL_CELLS}) {
            cellOffsets[index] = 0xFFFFFFFFu; 
        }

        if (index >= ${NUM_PARTICLES}) { return; }
        
        let p = particles[index];
        let cellID = getGridHash(p.pos);
        
        sortBuffer[index].key = cellID;
        sortBuffer[index].value = index;
    }
`;

// 2. Sort (Bitonic)
const computeSortWGSL = `
    ${commonWGSL}
    struct SortUniforms { algo: u32, step: u32 };
    @group(0) @binding(0) var<uniform> uSort : SortUniforms;
    @group(0) @binding(1) var<storage, read_write> data : array<SortKeyPair>;

    @compute @workgroup_size(64)
    fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
        let i = GlobalInvocationID.x;
        let j = i ^ uSort.step;
        if (j <= i) { return; }

        var a = data[i];
        var b = data[j];

        let dir = ((i & uSort.algo) != 0u);
        let cmp = a.key > b.key;

        if (dir == cmp) {
            data[i] = b;
            data[j] = a;
        }
    }
`;

// 3. Offsets
const computeOffsetsWGSL = `
    ${commonWGSL}
    @group(0) @binding(0) var<storage, read> sortBuffer : array<SortKeyPair>;
    @group(0) @binding(1) var<storage, read_write> cellOffsets : array<u32>;
    @group(0) @binding(2) var<storage, read_write> cellCounts : array<atomic<u32>>;

    @compute @workgroup_size(64)
    fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
        let index = GlobalInvocationID.x;
        if (index >= ${NUM_PARTICLES}) { return; }

        let key = sortBuffer[index].key;
        let keyPrev = sortBuffer[max(index - 1u, 0u)].key;

        if (index == 0u || key != keyPrev) {
            cellOffsets[key] = index;
        }
        atomicAdd(&cellCounts[key], 1u);
    }
`;

// 4. Clear Counts
const computeClearCountsWGSL = `
    @group(0) @binding(0) var<storage, read_write> cellCounts : array<atomic<u32>>;
    @compute @workgroup_size(64)
    fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
        if (GlobalInvocationID.x < ${GRID_TOTAL_CELLS}) { atomicStore(&cellCounts[GlobalInvocationID.x], 0u); }
    }
`;

const computeClearOffsetsWGSL = `
    @group(0) @binding(0) var<storage, read_write> cellOffsets : array<u32>;
    @compute @workgroup_size(64)
    fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
        if (GlobalInvocationID.x < ${GRID_TOTAL_CELLS}) { cellOffsets[GlobalInvocationID.x] = 0xFFFFFFFFu; }
    }
`;

// 5. Forces (compute only, brute force all pairs)
const computeForcesWGSL = `
    ${commonWGSL}
    @group(0) @binding(0) var<uniform> params : Params;
    @group(0) @binding(1) var<storage, read> particlesIn : array<Particle>;
    @group(0) @binding(2) var<storage, read_write> forces : array<vec2<f32>>;

    fn pairwiseForce(pa: vec2<f32>, pb: vec2<f32>, qq: f32, r2max: f32) -> vec2<f32> {
        let d = pa - pb;
        let r2 = dot(d, d);
        if (r2 < r2max && r2 > 0.0001) {
            let mr2 = r2max - r2;
            let fr = (1.0/(r2 + 0.01) + qq - 0.1) * mr2 * mr2;
            return d * fr;
        }
        return vec2<f32>(0.0);
    }

    @compute @workgroup_size(64)
    fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
        let index = GlobalInvocationID.x;
        if (index >= ${NUM_PARTICLES}) { return; }

        let p = particlesIn[index];
        var force = vec2<f32>(0.0);
        for (var j = 0u; j < ${NUM_PARTICLES}u; j++) {
            if (j == index) { continue; }
            let otherP = particlesIn[j];
            let qq = p.charge * otherP.charge;
            force += pairwiseForce(p.pos, otherP.pos, qq, params.r2max);
        }
        forces[index] = force;
    }
`;

// 6. Integrate (apply forces)
const computeIntegrateWGSL = `
    ${commonWGSL}
    @group(0) @binding(0) var<uniform> params : Params;
    @group(0) @binding(1) var<storage, read> particlesIn : array<Particle>;
    @group(0) @binding(2) var<storage, read> forces : array<vec2<f32>>;
    @group(0) @binding(3) var<storage, read_write> particlesOut : array<Particle>;

    @compute @workgroup_size(64)
    fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
        let index = GlobalInvocationID.x;
        if (index >= ${NUM_PARTICLES}) { return; }

        var p = particlesIn[index];
        let f = forces[index];
        p.vel += f * params.dt;
        p.vel *= params.damping;
        p.pos += p.vel * params.dt;

        let bound = params.gridDim * params.cellSize;
        if(p.pos.x < 0.0) { p.pos.x = 0.0; p.vel.x *= -1.0; }
        if(p.pos.x > bound) { p.pos.x = bound; p.vel.x *= -1.0; }
        if(p.pos.y < 0.0) { p.pos.y = 0.0; p.vel.y *= -1.0; }
        if(p.pos.y > bound) { p.pos.y = bound; p.vel.y *= -1.0; }

        particlesOut[index] = p;
    }
`;

// 6. Renderer
const renderWGSL = `
    struct Particle { pos: vec2<f32>, vel: vec2<f32>, charge: f32, pad: f32 };
    @group(0) @binding(0) var<storage, read> particles : array<Particle>;
    
    struct VertexOut { @builtin(position) pos : vec4<f32>, @location(0) color : vec4<f32>, @location(1) uv : vec2<f32> };

    @vertex
    fn vs_main(@builtin(vertex_index) vIdx : u32, @builtin(instance_index) iIdx : u32) -> VertexOut {
        let p = particles[iIdx];
        var out : VertexOut;
        
        // Quad generation
        var corn = vec2<f32>(0.0);
        let id = vIdx % 6u;
        if(id==0u || id==3u){ corn = vec2<f32>(-1., -1.); }
        else if(id==1u){ corn = vec2<f32>(1., -1.); }
        else { corn = vec2<f32>(1., 1.); }
        if(id==5u){ corn = vec2<f32>(-1., 1.); }
        out.uv = corn;

        // Map [0, WorldSize] -> [-1, 1]
        let worldSize = ${WORLD_SIZE.toFixed(1)};
        let ndcPos = (p.pos / worldSize) * 2.0 - 1.0;
        
        // Size of particle (fixed NDC size)
        let size = 0.05; 
        out.pos = vec4<f32>(ndcPos + corn * size, 0.0, 1.0);

        // Color
        if(p.charge > 0.0) { out.color = vec4<f32>(1.0, 0.2, 0.2, 1.0); }
        else { out.color = vec4<f32>(0.2, 0.2, 1.0, 1.0); }
        
        return out;
    }

    @fragment
    fn fs_main(@location(0) color : vec4<f32>, @location(1) uv : vec2<f32>) -> @location(0) vec4<f32> {
        if(dot(uv,uv) > 1.0) { discard; }
        return color;
    }
`;

const gridRenderWGSL = `
    @vertex
    fn vs_main(@builtin(vertex_index) vIdx : u32) -> @builtin(position) vec4<f32> {
        // Draw Grid Lines
        let dim = ${GRID_DIM}u;
        let lineIdx = vIdx / 2u;
        let isVert = lineIdx < (dim + 1u);
        let k = f32(lineIdx % (dim + 1u)) / f32(dim); // 0.0 to 1.0
        
        var pos = vec2<f32>(0.0);
        if(isVert) {
            // Vertical lines
            pos.x = k * 2.0 - 1.0;
            pos.y = (f32(vIdx % 2u) * 2.0) - 1.0; 
        } else {
            // Horizontal lines
            pos.y = k * 2.0 - 1.0;
            pos.x = (f32(vIdx % 2u) * 2.0) - 1.0;
        }
        return vec4<f32>(pos, 0.0, 1.0);
    }

    @fragment
    fn fs_main() -> @location(0) vec4<f32> {
        return vec4<f32>(0.5, 0.5, 0.5, 1.0);
    }
`;


// =========================================================
// JAVASCRIPT SETUP
// =========================================================

async function init() {
    const adapter = await navigator.gpu.requestAdapter();
    const device = await adapter.requestDevice();
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('webgpu');
    ctx.configure({ device, format: navigator.gpu.getPreferredCanvasFormat() });

    // --- 1. Init Data ---
    const pData = new Float32Array(NUM_PARTICLES * STRIDE); 
    for(let i=0; i<NUM_PARTICLES; i++) {
        // Random in full world span
        const o = i*STRIDE;
        pData[o+0] = Math.random() * WORLD_SIZE; // x
        pData[o+1] = Math.random() * WORLD_SIZE; // y
        pData[o+2] = 0.0; // vx
        pData[o+3] = 0.0; // vy
        pData[o+4] = (Math.random() < 0.5) ? 1.0 : -1.0; // Charge
        pData[o+5] = 0.0; // pad
    }

    const bufSize = pData.byteLength;
    
    // Buffers
    const bufA = device.createBuffer({ size: bufSize, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });
    const bufB = device.createBuffer({ size: bufSize, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });
    device.queue.writeBuffer(bufA, 0, pData);
    device.queue.writeBuffer(bufB, 0, pData);

    // Staging Buffer for Readback (Map Read)
    const bufReadback = device.createBuffer({ size: bufSize, usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST });

    const bufParams = device.createBuffer({ size: SIM_PARAMS.byteLength, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    device.queue.writeBuffer(bufParams, 0, SIM_PARAMS);

    const bufForcesBrute = device.createBuffer({ size: NUM_PARTICLES * 8, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });
    const bufForcesGrid  = device.createBuffer({ size: NUM_PARTICLES * 8, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });
    const bufForcesReadbackBrute = device.createBuffer({ size: NUM_PARTICLES * 8, usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST });
    const bufForcesReadbackGrid  = device.createBuffer({ size: NUM_PARTICLES * 8, usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST });

    // Grid buffers (for grid-accelerated forces)
    const bufSort = device.createBuffer({ size: NUM_PARTICLES * 8, usage: GPUBufferUsage.STORAGE });
    const bufOffsets = device.createBuffer({ size: GRID_TOTAL_CELLS * 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
    const bufCounts  = device.createBuffer({ size: GRID_TOTAL_CELLS * 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
    const bufSortUniform = device.createBuffer({ size: 8, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });

    // --- 2. Pipelines ---

    const mkPipe = (code, ent) => device.createComputePipeline({layout:'auto',compute:{module:device.createShaderModule({code}), entryPoint:ent}});
    
    const pipeForce = mkPipe(computeForcesWGSL, 'main');
    const pipeForceGrid = mkPipe(computeForcesGridWGSL, 'main');
    const pipeIntegrate = mkPipe(computeIntegrateWGSL, 'main');

    const pipeBinning = mkPipe(computeBinningWGSL, 'main');
    const pipeSort = mkPipe(computeSortWGSL, 'main');
    const pipeClearCounts = mkPipe(computeClearCountsWGSL, 'main');
    const pipeClearOffsets = mkPipe(computeClearOffsetsWGSL, 'main');
    const pipeOffsets = mkPipe(computeOffsetsWGSL, 'main');

    // BindGroups
    const mkBG = (layout, entries) => device.createBindGroup({ layout, entries });
    
    const bgForceA = mkBG(pipeForce.getBindGroupLayout(0), [
        {binding:0, resource:{buffer:bufParams}}, {binding:1, resource:{buffer:bufA}}, {binding:2, resource:{buffer:bufForcesBrute}}
    ]);
    const bgForceB = mkBG(pipeForce.getBindGroupLayout(0), [
        {binding:0, resource:{buffer:bufParams}}, {binding:1, resource:{buffer:bufB}}, {binding:2, resource:{buffer:bufForcesBrute}}
    ]);

    const bgIntegrateAB_Brute = mkBG(pipeIntegrate.getBindGroupLayout(0), [
        {binding:0, resource:{buffer:bufParams}}, {binding:1, resource:{buffer:bufA}}, {binding:2, resource:{buffer:bufForcesBrute}}, {binding:3, resource:{buffer:bufB}}
    ]);
    const bgIntegrateBA_Brute = mkBG(pipeIntegrate.getBindGroupLayout(0), [
        {binding:0, resource:{buffer:bufParams}}, {binding:1, resource:{buffer:bufB}}, {binding:2, resource:{buffer:bufForcesBrute}}, {binding:3, resource:{buffer:bufA}}
    ]);
    const bgIntegrateAB_Grid = mkBG(pipeIntegrate.getBindGroupLayout(0), [
        {binding:0, resource:{buffer:bufParams}}, {binding:1, resource:{buffer:bufA}}, {binding:2, resource:{buffer:bufForcesGrid}}, {binding:3, resource:{buffer:bufB}}
    ]);
    const bgIntegrateBA_Grid = mkBG(pipeIntegrate.getBindGroupLayout(0), [
        {binding:0, resource:{buffer:bufParams}}, {binding:1, resource:{buffer:bufB}}, {binding:2, resource:{buffer:bufForcesGrid}}, {binding:3, resource:{buffer:bufA}}
    ]);

    const bgClearOffsets = mkBG(pipeClearOffsets.getBindGroupLayout(0), [
        {binding:0, resource:{buffer:bufOffsets}}
    ]);
    const bgClearCounts = mkBG(pipeClearCounts.getBindGroupLayout(0), [
        {binding:0, resource:{buffer:bufCounts}}
    ]);
    const bgBinningA = mkBG(pipeBinning.getBindGroupLayout(0), [
        {binding:0, resource:{buffer:bufParams}}, {binding:1, resource:{buffer:bufA}}, {binding:2, resource:{buffer:bufSort}}, {binding:3, resource:{buffer:bufOffsets}}
    ]);
    const bgBinningB = mkBG(pipeBinning.getBindGroupLayout(0), [
        {binding:0, resource:{buffer:bufParams}}, {binding:1, resource:{buffer:bufB}}, {binding:2, resource:{buffer:bufSort}}, {binding:3, resource:{buffer:bufOffsets}}
    ]);
    const bgSort = mkBG(pipeSort.getBindGroupLayout(0), [
        {binding:0, resource:{buffer:bufSortUniform}}, {binding:1, resource:{buffer:bufSort}}
    ]);
    const bgOffsets = mkBG(pipeOffsets.getBindGroupLayout(0), [
        {binding:0, resource:{buffer:bufSort}}, {binding:1, resource:{buffer:bufOffsets}}, {binding:2, resource:{buffer:bufCounts}}
    ]);

    const bgForceGridA = mkBG(pipeForceGrid.getBindGroupLayout(0), [
        {binding:0, resource:{buffer:bufParams}}, {binding:1, resource:{buffer:bufA}}, {binding:2, resource:{buffer:bufForcesGrid}},
        {binding:3, resource:{buffer:bufSort}}, {binding:4, resource:{buffer:bufOffsets}}, {binding:5, resource:{buffer:bufCounts}}
    ]);
    const bgForceGridB = mkBG(pipeForceGrid.getBindGroupLayout(0), [
        {binding:0, resource:{buffer:bufParams}}, {binding:1, resource:{buffer:bufB}}, {binding:2, resource:{buffer:bufForcesGrid}},
        {binding:3, resource:{buffer:bufSort}}, {binding:4, resource:{buffer:bufOffsets}}, {binding:5, resource:{buffer:bufCounts}}
    ]);

    // Render Pipeline
    const modRender = device.createShaderModule({code:renderWGSL});
    const pipeRender = device.createRenderPipeline({
        layout: 'auto',
        vertex: { module: modRender, entryPoint: 'vs_main' },
        fragment: { module: modRender, entryPoint: 'fs_main', targets: [{ format: navigator.gpu.getPreferredCanvasFormat() }] },
        primitive: { topology: 'triangle-list' }
    });
    const bgRenderA = mkBG(pipeRender.getBindGroupLayout(0), [{binding:0, resource:{buffer:bufA}}]);
    const bgRenderB = mkBG(pipeRender.getBindGroupLayout(0), [{binding:0, resource:{buffer:bufB}}]);

    // Grid Render Pipeline
    const modGrid = device.createShaderModule({code:gridRenderWGSL});
    const pipeGrid = device.createRenderPipeline({
        layout: 'auto',
        vertex: { module: modGrid, entryPoint: 'vs_main' },
        fragment: { module: modGrid, entryPoint: 'fs_main', targets: [{ format: navigator.gpu.getPreferredCanvasFormat() }] },
        primitive: { topology: 'line-list' }
    });


    // --- 3. Execution Logic ---

    let inA = true;
    let stepCount = 0;
    let autoRun = false;
    let running = false;
    let substeps = 1;
    let algMode = 'brute';
    let picked = -1;
    let lastParticles = null;
    let lastForceDiff = '';

    function userSelectingText(){
        const sel = window.getSelection?.();
        return sel && sel.type === 'Range' && sel.toString().length > 0;
    }

    const updateParams = () => {
        device.queue.writeBuffer(bufParams, 0, SIM_PARAMS);
        if(!userSelectingText()) document.getElementById('status').innerText = `dt=${SIM_PARAMS[0].toFixed(3)} damp=${SIM_PARAMS[1].toFixed(3)} r2=${SIM_PARAMS[2].toFixed(1)}`;
    };

    function compareForces(brute, grid){
        let maxD2 = 0.0;
        let maxI = -1;
        let maxBx = 0.0, maxBy = 0.0, maxGx = 0.0, maxGy = 0.0;
        for(let i=0; i<NUM_PARTICLES; i++){
            const ox = i*2;
            const bx = brute[ox], by = brute[ox+1];
            const gx = grid[ox],  gy = grid[ox+1];
            const dx = bx-gx, dy = by-gy;
            const d2 = dx*dx + dy*dy;
            if(d2 > maxD2){ maxD2=d2; maxI=i; maxBx=bx; maxBy=by; maxGx=gx; maxGy=gy; }
        }
        return { maxD: Math.sqrt(maxD2), idx: maxI, bx:maxBx, by:maxBy, gx:maxGx, gy:maxGy };
    }

    async function stepOnce(wg){
        if(algMode === 'grid'){
            // IMPORTANT: queue.writeBuffer() is not recorded into a command encoder.
            // Therefore, each sort stage must be submitted separately to guarantee
            // the GPU sees the correct (k,j) uniforms.

            // Phase 0: clearOffsets + binning + clearCounts (single submission)
            {
                const enc = device.createCommandEncoder();
                const passClrO = enc.beginComputePass();
                passClrO.setPipeline(pipeClearOffsets);
                passClrO.setBindGroup(0, bgClearOffsets);
                passClrO.dispatchWorkgroups(Math.ceil(GRID_TOTAL_CELLS/64));
                passClrO.end();

                const passBin = enc.beginComputePass();
                passBin.setPipeline(pipeBinning);
                passBin.setBindGroup(0, inA ? bgBinningA : bgBinningB);
                passBin.dispatchWorkgroups(wg);
                passBin.end();

                const passClrC = enc.beginComputePass();
                passClrC.setPipeline(pipeClearCounts);
                passClrC.setBindGroup(0, bgClearCounts);
                passClrC.dispatchWorkgroups(Math.ceil(GRID_TOTAL_CELLS/64));
                passClrC.end();

                device.queue.submit([enc.finish()]);
            }

            // Phase 1: bitonic sort (each stage submitted separately)
            for (let k = 2; k <= NUM_PARTICLES; k <<= 1) {
                for (let j = k >> 1; j > 0; j >>= 1) {
                    device.queue.writeBuffer(bufSortUniform, 0, new Uint32Array([k, j]));
                    const encSort = device.createCommandEncoder();
                    const pass = encSort.beginComputePass();
                    pass.setPipeline(pipeSort);
                    pass.setBindGroup(0, bgSort);
                    pass.dispatchWorkgroups(wg);
                    pass.end();
                    device.queue.submit([encSort.finish()]);
                }
            }

            // Phase 2: offsets + forces + parity copy (single submission)
            {
                const enc2 = device.createCommandEncoder();

                const passOff = enc2.beginComputePass();
                passOff.setPipeline(pipeOffsets);
                passOff.setBindGroup(0, bgOffsets);
                passOff.dispatchWorkgroups(wg);
                passOff.end();

                const passForce = enc2.beginComputePass();
                passForce.setPipeline(pipeForceGrid);
                passForce.setBindGroup(0, inA ? bgForceGridA : bgForceGridB);
                passForce.dispatchWorkgroups(wg);
                passForce.end();

                // Also compute brute forces on the same input state for parity check
                const passForceBrute = enc2.beginComputePass();
                passForceBrute.setPipeline(pipeForce);
                passForceBrute.setBindGroup(0, inA ? bgForceA : bgForceB);
                passForceBrute.dispatchWorkgroups(wg);
                passForceBrute.end();

                enc2.copyBufferToBuffer(bufForcesBrute, 0, bufForcesReadbackBrute, 0, NUM_PARTICLES*8);
                enc2.copyBufferToBuffer(bufForcesGrid,  0, bufForcesReadbackGrid,  0, NUM_PARTICLES*8);

                device.queue.submit([enc2.finish()]);
            }
        } else {
            // Brute: force (single submission)
            const enc = device.createCommandEncoder();
            const passForce = enc.beginComputePass();
            passForce.setPipeline(pipeForce);
            passForce.setBindGroup(0, inA ? bgForceA : bgForceB);
            passForce.dispatchWorkgroups(wg);
            passForce.end();

            // Integrate
            const passInt = enc.beginComputePass();
            passInt.setPipeline(pipeIntegrate);
            passInt.setBindGroup(0, inA ? bgIntegrateAB_Brute : bgIntegrateBA_Brute);
            passInt.dispatchWorkgroups(wg);
            passInt.end();

            device.queue.submit([enc.finish()]);
            inA = !inA;
            stepCount++;
            return;
        }

        // Grid: integrate (separate submission after force buffers were produced)
        {
            const encInt = device.createCommandEncoder();
            const passInt = encInt.beginComputePass();
            passInt.setPipeline(pipeIntegrate);
            passInt.setBindGroup(0, inA ? bgIntegrateAB_Grid : bgIntegrateBA_Grid);
            passInt.dispatchWorkgroups(wg);
            passInt.end();
            device.queue.submit([encInt.finish()]);
        }

        inA = !inA;
        stepCount++;
    }

    async function step() {
        if(running) return; running = true;
        const wg = Math.ceil(NUM_PARTICLES / 64);

        for(let s=0; s<substeps; s++){
            await stepOnce(wg);

            // Render only on last substep (separate command buffer)
            if(s === substeps-1){
                const encR = device.createCommandEncoder();
                const passRender = encR.beginRenderPass({
                    colorAttachments: [{
                        view: ctx.getCurrentTexture().createView(),
                        clearValue: { r: 0.1, g: 0.1, b: 0.1, a: 1 },
                        loadOp: 'clear', storeOp: 'store'
                    }]
                });
                passRender.setPipeline(pipeGrid);
                passRender.draw((GRID_DIM + 1) * 4); 
                passRender.setPipeline(pipeRender);
                passRender.setBindGroup(0, inA ? bgRenderB : bgRenderA);
                passRender.draw(6, NUM_PARTICLES);
                passRender.end();

                encR.copyBufferToBuffer(inA ? bufB : bufA, 0, bufReadback, 0, bufSize);
                device.queue.submit([encR.finish()]);
            }
        }

        // Debug Read (CPU) after final substep
        await bufReadback.mapAsync(GPUMapMode.READ);
        const resP = new Float32Array(bufReadback.getMappedRange());
        lastParticles = new Float32Array(resP);
        printLog(stepCount-1, resP, new Uint32Array());
        bufReadback.unmap();

        if(algMode === 'grid'){
            await bufForcesReadbackBrute.mapAsync(GPUMapMode.READ);
            await bufForcesReadbackGrid.mapAsync(GPUMapMode.READ);
            const fB = new Float32Array(bufForcesReadbackBrute.getMappedRange());
            const fG = new Float32Array(bufForcesReadbackGrid.getMappedRange());
            const c = compareForces(fB, fG);
            lastForceDiff = `ForceDiff max=${c.maxD.toExponential(3)} @i=${c.idx} brute=(${c.bx.toExponential(3)},${c.by.toExponential(3)}) grid=(${c.gx.toExponential(3)},${c.gy.toExponential(3)})`;
            bufForcesReadbackBrute.unmap();
            bufForcesReadbackGrid.unmap();
            const box = document.getElementById('forceDiffBox');
            if(box) box.value = lastForceDiff;
            if(!userSelectingText()) document.getElementById('status').innerText = `GRID ${lastForceDiff}`;
        }

        running = false;
        if(autoRun) requestAnimationFrame(()=>step());
    }

    // --- UI Logic ---

    function printLog(frame, particles, sortKeys) {
        if(userSelectingText()) return;
        const log = document.getElementById('logs');
        let html = `<b>FRAME ${frame}</b>\n`;
        if(lastForceDiff) html += `<b>${lastForceDiff}</b>\n\n`;
        html += `IDX | POS (X, Y)     | VEL (X, Y)     | Q  | CellID (Key)\n`;
        html += `--------------------------------------------------------\n`;

        // Create a map of index -> sortKey for display
        // sortKeys array is [Key, Value, Key, Value...]
        let keyMap = {};
        for(let i=0; i<NUM_PARTICLES; i++) {
            keyMap[sortKeys[i*2+1]] = sortKeys[i*2];
        }

        for(let i=0; i<NUM_PARTICLES; i++) {
            const base = i*STRIDE;
            const x = particles[base].toFixed(2);
            const y = particles[base+1].toFixed(2);
            const vx = particles[base+2].toFixed(3);
            const vy = particles[base+3].toFixed(3);
            const q = particles[base+4] > 0 ? "+" : "-";
            const k = keyMap[i] !== undefined ? keyMap[i] : "?";

            // Grid Coords calculation for verification
            const gx = Math.floor(particles[base] / CELL_SIZE);
            const gy = Math.floor(particles[base+1] / CELL_SIZE);
            const expectedK = gy * GRID_DIM + gx;
            
            let extra = "";
            if (k != expectedK) extra = `<span class='hl'> MISMATCH(${expectedK})</span>`;

            html += `${i.toString().padStart(3)} | ${x.padStart(5)}, ${y.padStart(5)} | ${vx.padStart(6)}, ${vy.padStart(6)} | ${q}  | ${k}${extra}\n`;
        }
        
        // Show Sorted List
        html += `\n<b>Sorted Buffer (Bitonic Result):</b>\n`;
        for(let i=0; i<NUM_PARTICLES; i++) {
            html += `[${i}]: Key=${sortKeys[i*2]} Val=${sortKeys[i*2+1]}\n`;
        }

        log.innerHTML = html;
    }

    document.getElementById('btnStep').onclick = () => { autoRun=false; step(); };
    document.getElementById('btnRun').onclick = () => { autoRun = !autoRun; if(autoRun) step(); };

    // Param inputs
    const inpDt = document.getElementById('inpDt');
    const inpDamp = document.getElementById('inpDamp');
    const inpR2 = document.getElementById('inpR2');
    const inpSub = document.getElementById('inpSub');
    const selAlg = document.getElementById('selAlg');
    const btnCopyDiff = document.getElementById('btnCopyDiff');
    inpDt.value = SIM_PARAMS[0];
    inpDamp.value = SIM_PARAMS[1];
    inpR2.value = SIM_PARAMS[2];
    inpSub.value = substeps;
    const clamp = (v,min,max)=>Math.min(Math.max(v,min),max);
    inpDt.oninput = () => { SIM_PARAMS[0] = clamp(parseFloat(inpDt.value)||SIM_PARAMS[0],0.001,1.0); updateParams(); };
    inpDamp.oninput = () => { SIM_PARAMS[1] = clamp(parseFloat(inpDamp.value)||SIM_PARAMS[1],0.0,1.0); updateParams(); };
    inpR2.oninput = () => { SIM_PARAMS[2] = clamp(parseFloat(inpR2.value)||SIM_PARAMS[2],0.1,128.0); updateParams(); };
    inpSub.oninput = () => { substeps = Math.max(1, Math.min(32, parseInt(inpSub.value)||substeps)); };
    selAlg.onchange = () => { algMode = selAlg.value; };
    btnCopyDiff.onclick = async () => {
        const box = document.getElementById('forceDiffBox');
        const txt = (box && box.value) ? box.value : lastForceDiff;
        if(!txt) return;
        try {
            await navigator.clipboard.writeText(txt);
        } catch (e) {
            // Fallback for older contexts
            if(box){
                box.focus();
                box.select();
                document.execCommand('copy');
            }
        }
    };
    updateParams();

    // Mouse picking/dragging
    const worldFromMouse = (evt)=>{
        const rect = canvas.getBoundingClientRect();
        const x = ((evt.clientX - rect.left) / rect.width) * WORLD_SIZE;
        const y = (1.0 - (evt.clientY - rect.top ) / rect.height) * WORLD_SIZE;
        return {x,y};
    };
    const writeParticlePos = (idx, x, y)=>{
        const offset = idx * STRIDE * 4;
        const q = lastParticles ? lastParticles[idx*STRIDE+4] : 1.0;
        const tmp = new Float32Array([x,y,0,0,q,0]);
        device.queue.writeBuffer(bufA, offset, tmp);
        device.queue.writeBuffer(bufB, offset, tmp);
    };
    canvas.addEventListener('mousedown',(e)=>{
        if(!lastParticles) return;
        const m = worldFromMouse(e);
        let best=-1, bestR2=1e9;
        for(let i=0;i<NUM_PARTICLES;i++){
            const px=lastParticles[i*STRIDE], py=lastParticles[i*STRIDE+1];
            const dx=px-m.x, dy=py-m.y;
            const r2=dx*dx+dy*dy;
            if(r2<bestR2 && r2<4.0){bestR2=r2;best=i;} // radius 2 units
        }
        picked=best;
        if(picked>=0){ writeParticlePos(picked,m.x,m.y); if(!autoRun) step(); }
    });
    canvas.addEventListener('mousemove',(e)=>{
        if(picked<0) return;
        const m = worldFromMouse(e);
        writeParticlePos(picked,m.x,m.y);
    });
    window.addEventListener('mouseup',()=>{picked=-1;});

    // First draw
    step();
}

init();

</script>
</body>
</html>